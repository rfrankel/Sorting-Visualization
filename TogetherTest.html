<!DOCTYPE html>
<meta charset="utf-8">
<head>
<style>

/* Weave Brush styles */

body {
  font: 10px sans-serif;
  shape-rendering: crispEdges;
}

.grid-background {
  fill: #ddd;
}

.grid line {
  stroke: #fff;
}

.grid .minor line {
  stroke-opacity: .5;
}

.grid text {
  display: none;
}

.axis line {
  stroke: #000;
}

.axis path,
.grid path {
  display: none;
}

.brush .extent {
  stroke: #000;
  fill-opacity: .125;
  shape-rendering: crispEdges;
}

/* Tree styles */

.node {
  cursor: pointer;
}

.node circle {
  fill: #fff;
  stroke: steelblue;
  stroke-width: 2px;
}

.node text {
  font: 10px sans-serif;
}

.link {
  fill: none;
  stroke: #ccc;
  stroke-width: 2px;
}

</style>
</head>
<body>
<script src="http://d3js.org/d3.v3.js"></script>
<script>

var tmargin = {top: 20, right: 150, bottom: 20, left: 100},
    twidth = 800 - tmargin.right - tmargin.left,
    theight = 800 - tmargin.top - tmargin.bottom;

var wmargin = {top: 20, right: 200, bottom: 20, left: 200},
    wwidth = 640 - wmargin.right - wmargin.left,
    wheight = 760 - wmargin.top - wmargin.bottom;

var x = d3.scale.linear()
    .range([0, wwidth]);

// Sortvis makes weave ends that are 2% of the total
var weavend = wheight*.02;
// Number of levels in this tree, and pixels per level
var numLevels = 20;
var levelPix = (wheight-2*weavend)/numLevels;

var y = d3.scale.linear()
    .domain([0, 20])
    .range([weavend, wheight-weavend]);

var svg = d3.select("body").append("svg")
    .attr("width", twidth + tmargin.right + tmargin.left + wwidth + wmargin.right + wmargin.left)
    .attr("height", wheight + wmargin.top + wmargin.bottom + theight + tmargin.top + tmargin.bottom)
  .append("g")
    .attr("transform", "translate(" + (twidth + tmargin.right + tmargin.left + wmargin.left) + "," + wmargin.top + ")");

// -------------  Brushed Weave Pattern
	
var defs = svg.append('svg:defs')
defs.append('svg:pattern')
    .attr('id', 'weavepat')
    .attr('patternUnits', 'userSpaceOnUse')
    .attr('width', '240')
    .attr('height', '720')
    .append('svg:image')
    .attr('xlink:href', 'svseqbright.png')
    .attr('x', 0)
    .attr('y', 0)
    .attr('width', 240)
    .attr('height', 720);

svg.append("rect")
    .attr("class", "grid-background")
    .attr("width", wwidth)
    .attr("height", wheight)
    .style("fill", "url(#weavepat)")

svg.append("g")
    .attr("class", "grid")
    .call(d3.svg.axis().scale(y).orient("left").ticks(40).tickSize(-wwidth))
  .selectAll(".tick")
    .data(y.ticks(20), function(d) { return d; })
  .exit()
    .classed("minor", true);

svg.append("g")
    .attr("class", "axis")
    .call(d3.svg.axis().scale(y).orient("left").ticks(20));

var brush = d3.svg.brush()
    .y(y)
    .extent([3, 7])
    .on("brush", brushed);

var gBrush = svg.append("g")
    .attr("class", "brush")
    .call(brush);
gBrush.selectAll("rect")
    .attr("width", wwidth);

function brushed() {
  var extent0 = brush.extent(),
      extent1;

  // if dragging, preserve the width of the extent
  if (d3.event.mode === "move") {
    //console.log("Extent: %o",extent0);
    var d0 = d3.round(extent0[0]),
        d1 = d0 + Math.round((extent0[1] - extent0[0]));
    //console.log("Start of brush extent: %d",d0)
    extent1 = [d0, d1];
  }

  // otherwise, if resizing, round both dates
  else {
    extent1 = extent0.map(function(n) { return d3.round(n,0)});
    console.log("Extent: %o",extent1);

    // if empty when rounded, use floor & ceil instead
    // this doesn't work for things other than dates
    // need something else (TODO!)
    if (extent1[0] >= extent1[1]) {
      extent1[1] = d3.round(extent0[1]);
      extent1[0] = extent1[1] - 1;
    }
  }

  d3.select(this).call(brush.extent(extent1));
  
  root.children.forEach(function(d) {redrawOnTick(extent1[1],d);});
  update(root,extent1[1]);
}

function redrawOnTick(tck,d) {
    if (d.children && d.tick >= tck) {
      d._children = d.children;
      d._children.forEach(function(d) {redrawOnTick(tck,d);});
      d.children = null;
    }
  }


// ----------- Tree -------------------

var i = 0,
    duration = 750,
    root;

var tree = d3.layout.tree()
    .size([theight, twidth])
    .separation(function separation(a, b) {
    if (a.parent == b.parent) 
     if ((a.tick - a.depth) > 1) 
      return ((a.tick - a.parent.tick)/2)
     else if ((b.tick - b.depth) > 1)
      return ((b.tick - b.parent.tick)/2) 
     else 
      return 1
    else 
     return 2
    }
);

// Old separation function
//    if ((a.parent == b.parent) && (((a.tick - a.depth) > 0) || ((b.tick - b.depth) > 0)))

var diagonal = d3.svg.diagonal()
    .projection(function(d) { return [d.x, d.y]; });

var treegr = svg.append("g")
    .attr("transform", "translate(" + -1*(tmargin.right + wwidth + wmargin.right + wmargin.left) + "," + weavend + ")");

d3.json("./qsortTrackPivot.json", function(error, flare) {
  root = flare;
  root.x0 = theight / 2;
  root.y0 = 0;

  function collapse(d) {
    if (d.children) {
      d._children = d.children;
      d._children.forEach(collapse);
      d.children = null;
    }
  }

  root.children.forEach(collapse);
  update(root,0);
});

d3.select(self.frameElement).style("height", "800px");

// Updates all the nodes below the given source on tick tck
// If tck == 0 then draw the tree uninfluenced by the tick
function update(source,tck) {
  console.log("Calling Update with tick %d", tck);
  // let tck default to 0
  tck = typeof tck !== 'undefined' ? tck : 0;

  // Compute the new tree layout.
  var nodes = tree.nodes(root).reverse(),
      links = tree.links(nodes);

  // Normalize for fixed-depth or show influence of tick
  if (tck == 0)
    nodes.forEach(function(d) { d.y = d.tick * levelPix; });
  else 
    nodes.forEach(function(d) {
      console.log("Considering node %O", d);
      if (!(d.name instanceof Array) && d.name != "Empty")  {
        console.log("Pivot -- Proposed y was tick level %d", tck);
        d.y = tck * levelPix;
      } else
        if (d.tick > 1 && d.parent.tick < tck && d.name instanceof Array) {
        console.log("Parent tick %d less than tck %d", d.parent.tick, tck);
        console.log("NonPivot: Proposed y was tick level %d", (d.parent.tick + 1));
        d.y = tck * levelPix;
      } else {
        console.log("Normal node: Proposed y was tick level %d", d.tick);
        d.y = d.tick * levelPix;
      }
   });
    

  // Update the nodes…
  var node = treegr.selectAll("g.node")
      .data(nodes, function(d) { return d.id || (d.id = ++i); });

  // Enter any new nodes at the parent's previous position.
  var nodeEnter = node.enter().append("g")
      .attr("class", "node")
      .attr("transform", function(d) { return "translate(" + source.x0 + "," + source.y0 + ")"; })
      .on("click", click);

  nodeEnter.append("circle")
      .attr("r", 1e-6)
      .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

  nodeEnter.append("text")
      .attr("x", function(d) { return d.children || d._children ? -10 : 10; })
      .attr("dy", ".35em")
      .attr("text-anchor", function(d) { return d.children || d._children ? "end" : "start"; })
      .text(function(d) { return d.name; })
      .style("fill-opacity", 1e-6);

  // Transition nodes to their new position.
  var nodeUpdate = node.transition()
      .duration(duration)
      .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });

  nodeUpdate.select("circle")
      .attr("r", 4.5)
      .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

  nodeUpdate.select("text")
      .style("fill-opacity", 1);

  // Transition exiting nodes to the parent's new position.
  var nodeExit = node.exit().transition()
      .duration(duration)
      .attr("transform", function(d) { return "translate(" + source.x + "," + source.y + ")"; })
      .remove();

  nodeExit.select("circle")
      .attr("r", 1e-6);

  nodeExit.select("text")
      .style("fill-opacity", 1e-6);

  // Update the links…
  var link = treegr.selectAll("path.link")
      .data(links, function(d) { return d.target.id; });

  // Enter any new links at the parent's previous position.
  link.enter().insert("path", "g")
      .attr("class", "link")
      .attr("d", function(d) {
        var o = {x: source.x0, y: source.y0};
        return diagonal({source: o, target: o});
      });

  // Transition links to their new position.
  link.transition()
      .duration(duration)
      .attr("d", diagonal);

  // Transition exiting nodes to the parent's new position.
  link.exit().transition()
      .duration(duration)
      .attr("d", function(d) {
        var o = {x: source.x, y: source.y};
        return diagonal({source: o, target: o});
      })
      .remove();

  // Stash the old positions for transition.
  nodes.forEach(function(d) {
    d.x0 = d.x;
    d.y0 = d.y;
  });
}

// Toggle children on click.
function click(d) {
  if (d.children) {
    d._children = d.children;
    d.children = null;
  } else {
    d.children = d._children;
    d._children = null;
  }
  update(d,0);
}


</script>

</body>
